#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pylint: disable=R0913,R0917

from abc import ABC, abstractmethod
import sys
from typing import List

import gi
gi.require_version('Gimp', '3.0')
from gi.repository import Gimp
gi.require_version('GimpUi', '3.0')
from gi.repository import GimpUi
from gi.repository import GObject
from gi.repository import GLib

# --- DEBUG ---
# import debugpy
# import importlib
# import inspect
# import os
# currentframe = os.path.dirname(inspect.getfile(inspect.currentframe()))
# sys.path.append(currentframe)
# sys.stderr = open(os.path.join(currentframe, "errors.txt"), 'w', buffering=1)
# sys.stdout = open(os.path.join(currentframe, "log.txt"), 'w', buffering=1)
# -------------

import palette_swap
import palette_swap.palette_swap_linear
import palette_swap.palette_swap_simple
import palette_swap.palette_to_layer


# I really don't understand why you can't register two plugin objects?
# This whole plugin setup is very bizarre.

class MetaPlugin(ABC):
    """
    The 'meta-plugin' that describes the interface for the sub-plugins.

    I just wanted to type hint this but it turns out abstract class properties are
    scheduled for deprecation, so the code looks like Java now.
    """
    @classmethod
    @abstractmethod
    def get_name(cls) -> str:  # pylint: disable=C0116
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def get_menu_label(cls) -> str:  # pylint: disable=C0116
        raise NotImplementedError

    @staticmethod
    def get_menu_path() -> str:  # pylint: disable=C0116
        return "<Image>/Filters/Map/Palette Swap"

    @classmethod
    @abstractmethod
    def get_documentation(cls) -> str:  # pylint: disable=C0116
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def get_dialog_fill(cls) -> list[str]:  # pylint: disable=C0116
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def arguments(
        cls: type, procedure: Gimp.ImageProcedure
    ):    # pylint: disable=C0116
        raise NotImplementedError

    @classmethod
    @abstractmethod
    def run(
        cls, procedure, run_mode, image, drawables, config, run_data
    ):
        raise NotImplementedError


class PaletteSwapLinearMetaPlugin(MetaPlugin):
    """
    Swaps the current layer from a source palette to a target palette
    """
    @classmethod
    def get_name(cls) -> str:
        return 'ttt-palette-swap-linear'

    @classmethod
    def get_menu_label(cls) -> str:
        return "Swap from old to new palette..."

    @classmethod
    def get_documentation(cls) -> str:
        return "Maps the colours from 1-pixel 'old' palette layer to an equivalent 'new' layer," \
            + "\nthen replaces all the 'old' colours in the current layer" \
            + " with the corresponding 'new' colours."

    @classmethod
    def get_dialog_fill(cls) -> list[str]:
        return [
            'layer-palette-old',
            'layer-palette-new',
        ]

    @classmethod
    def arguments(
            cls: type['PaletteSwapLinearMetaPlugin'],
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_layer_argument(
            name='layer-palette-old',
            nick="Old Palette Layer",
            blurb="1-pixel high layer containing colours to be replaced.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_layer_argument(
            name='layer-palette-new',
            nick="New Palette Layer",
            blurb="1-pixel high layer containing colours to replace them with.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data  # pylint: disable=W0613
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_swap_linear)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.get_name())
            dialog = GimpUi.ProcedureDialog.new(procedure, config, cls.get_menu_label())
            dialog.get_label(
                f'{cls.get_name()}-docs',
                cls.get_documentation(),
                False,
                False,
            )
            dialog.fill([f'{cls.get_name()}-docs']+cls.get_dialog_fill())
            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )

        layer_palette_old: Gimp.Layer = config.get_property('layer-palette-old')
        layer_palette_new: Gimp.Layer = config.get_property('layer-palette-new')

        invalid_layers: bool = False
        if layer_palette_new.get_height() != 1:
            Gimp.message(f"{layer_palette_new.get_name()} is not 1-pixel high!")
            invalid_layers = True

        if layer_palette_old.get_height() != 1:
            Gimp.message(f"{layer_palette_old.get_name()} is not 1-pixel high!")
            invalid_layers = True

        if invalid_layers:
            return procedure.new_return_values(
                Gimp.PDBStatusType.CALLING_ERROR, GLib.Error()
            )

        try:
            palette_swap.palette_swap_linear.palette_swap_linear(
                image,
                layer_target=image.get_selected_layers()[0],
                layer_palette_old=layer_palette_old,
                layer_palette_new=layer_palette_new,
            )
        except Exception as e:  # pylint: disable=W0718
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )

        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


class PaletteSwapSimpleMetaPlugin(MetaPlugin):
    """
    Maps the current layer to the palette auto-detected from another layer.
    """
    @classmethod
    def get_name(cls) -> str:
        return 'ttt-palette-swap-simple'

    @classmethod
    def get_menu_label(cls) -> str:
        return "Swap to sample layer's palette..."

    @classmethod
    def get_documentation(cls) -> str:
        return "Ranks colours in the current layer by brightness,\n" \
            + "ranks colours in the sample layer by brightness,\n" \
            + "then replaces colours colours in the current layer with their equivalent rank in the sample."

    @classmethod
    def get_dialog_fill(cls) -> list[str]:
        return [
            'layer-sample',
            'count-threshold',
            'include-transparent',
            'light-first',
        ]

    @classmethod
    def arguments(
            cls: type['PaletteSwapSimpleMetaPlugin'],
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_layer_argument(
            name="layer-sample",
            nick="Sample Layer",
            blurb="Layer to sample colours from.",
            none_ok=False,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_boolean_argument(
            name="include-transparent",
            nick="Sample transparent pixels",
            blurb="Whether or not to sample colours from transparent pixels.",
            value=True,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_int_argument(
            name="count-threshold",
            nick="Pixel count threshold",
            blurb="Ignore colours with less than this many pixels. May solve problems with rogue wrong-coloured pixels messing up palette detection.",
            min=0, max=GLib.MAXINT, value=5,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_boolean_argument(
            "light-first",
            "Map from lightest pixels down",
            "Go from the lightest to darkest instead. No effect if both have the same number of colours.",
            value=False,
            flags=GObject.ParamFlags.READWRITE
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data  # pylint: disable=W0613
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_to_layer)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.get_name())
            dialog = GimpUi.ProcedureDialog.new(procedure, config, cls.get_menu_label())
            dialog.get_label(
                f'{cls.get_name()}-docs',
                cls.get_documentation(),
                False,
                False,
            )
            dialog.fill([f'{cls.get_name()}-docs']+cls.get_dialog_fill())
            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )

        try:
            palette_swap.palette_swap_simple.palette_swap_simple(
                image,
                layer_target=image.get_selected_layers()[0],
                layer_sample=config.get_property("layer-sample"),
                include_transparent=config.get_property("include-transparent"),
                light_first=config.get_property("light-first"),
                count_threshold=config.get_property("count-threshold")
            )
        except Exception as e:  # pylint: disable=W0718
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )

        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


class PaletteToLayerMetaPlugin(MetaPlugin):
    """
    Creates a 1-pixel high 'palette' layer from the current layer.
    """
    @classmethod
    def get_name(cls) -> str:
        return 'ttt-palette-to-layer'

    @classmethod
    def get_menu_label(cls) -> str:
        return "Create layer from palette..."

    @classmethod
    def get_documentation(cls) -> str:
        return "Given a layer, creates a 1-pixel high layer that contains the colours within it, sorted by brightness."

    @classmethod
    def get_dialog_fill(cls) -> list[str]:
        return [
            'count-threshold',
            'include-transparent',
            'layer-name',
        ]

    @classmethod
    def arguments(
            cls: type['PaletteToLayerMetaPlugin'],
            procedure: Gimp.ImageProcedure
    ):
        """
        Adds arguments specific to this meta-plugin.

        :param cls: This class.
        :param procedure: The procedure to add arguments to.
        """
        procedure.add_boolean_argument(
            name="include-transparent",
            nick="Sample transparent pixels",
            blurb="Whether or not to sample colours from transparent pixels.",
            value=True,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_int_argument(
            name="count-threshold",
            nick="Pixel count threshold",
            blurb="Ignore colours with less than this many pixels. May solve problems with rogue wrong-coloured pixels messing up palette detection.",
            min=0, max=GLib.MAXINT, value=5,
            flags=GObject.ParamFlags.READWRITE
        )
        procedure.add_string_argument(
            name="layer-name",
            nick="Palette Layer Name",
            blurb="Name of the layer to create.",
            value="Palette",
            flags=GObject.ParamFlags.READWRITE,
        )

    @classmethod
    def run(
            cls, procedure, run_mode, image, drawables, config, run_data
    ):
        """
        The method called when the menu shortcut is run.

        :param cls: This class.
        :param procedure: The procedure being called.
        :param run_mode: Whether it's interactive or not.
        :param image: The current image.
        :param drawables: ...not used this?
        :param config: The config values for the procedure.
        :param run_data: ...not used this?
        :return: The return values generated by the procedure.
        """
        # debugpy.wait_for_client()
        # importlib.reload(palette_swap)
        # importlib.reload(palette_swap.palette_to_layer)

        if run_mode == Gimp.RunMode.INTERACTIVE:
            gi.require_version('Gtk', '3.0')

            GimpUi.init(cls.get_name())
            dialog = GimpUi.ProcedureDialog.new(
                procedure, config, cls.get_menu_label()
            )
            dialog.get_label(
                f'{cls.get_name()}-docs',
                cls.get_documentation(),
                False,
                False,
            )
            dialog.fill([f'{cls.get_name()}-docs']+cls.get_dialog_fill())

            if not dialog.run():
                return procedure.new_return_values(
                    Gimp.PDBStatusType.CANCEL, GLib.Error()
                )

        try:
            palette_swap.palette_to_layer.palette_to_layer(
                image,
                layer_sample=image.get_selected_layers()[0],
                include_transparent=config.get_property("include-transparent"),
                count_threshold=config.get_property("count-threshold"),
                layer_name=config.get_property("layer-name"),
            )
        except Exception as e:  # pylint: disable=W0718
            Gimp.message(f"{e}")
            return procedure.new_return_values(
                Gimp.PDBStatusType.EXECUTION_ERROR, GLib.Error()
            )

        # do what you want to do, then, in case of success, return:
        return procedure.new_return_values(Gimp.PDBStatusType.SUCCESS, GLib.Error())


PROCEDURES: dict[str, type[MetaPlugin]] = {
    'ttt-palette-swap-simple': PaletteSwapSimpleMetaPlugin,
    'ttt-palette-swap-linear': PaletteSwapLinearMetaPlugin,
    'ttt-palette-to-layer': PaletteToLayerMetaPlugin,
}


class PaletteSwapPlugin(Gimp.PlugIn):
    """
    Plugin that's actually registered with GIMP, to register the meta-plugins.
    """
    def do_query_procedures(self) -> List[str]:
        """List the procedures in the plugin"""
        return list(PROCEDURES.keys())

    def do_set_i18n (self, name: str) -> bool:  # pylint: disable=W0613
        """No translation for this plugin"""
        return False

    def do_create_procedure(self, name: str) -> Gimp.ImageProcedure:
        """
        Register each procedure.

        Does the 'standard' arguments, documentation, e.t.c.,
        then hands off to the metaplugin.

        :param name: The procedure name, from `do_query_procedures`.
        :return: Each individual procedure.
        """
        procedure = Gimp.ImageProcedure.new(
            self,
            name,
            Gimp.PDBProcType.PLUGIN,
            PROCEDURES[name].run,
            None,
        )
        procedure.set_image_types("RGBA")
        procedure.set_menu_label(PROCEDURES[name].get_menu_label())
        procedure.add_menu_path(PROCEDURES[name].get_menu_path())
        procedure.set_documentation(
            PROCEDURES[name].get_documentation(),
            PROCEDURES[name].get_documentation(),
            name
        )
        procedure.set_attribution(
            "Sam Mangham", "Sam Mangham", "2023"
        )
        PROCEDURES[name].arguments(procedure)
        return procedure


Gimp.main(PaletteSwapPlugin.__gtype__, sys.argv)
